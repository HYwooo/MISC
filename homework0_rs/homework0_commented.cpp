/**
 * homework0_commented.cpp
 * 数值计算作业 - 级数求和精度分析
 * 本程序演示了在数值计算中不同求和顺序对精度的影响
 * 通过三种不同的方法计算级数 S_n = Σ_{i=2}^n 1/(i²-1) 的和
 */

#include <iostream>
#include <iomanip>
using namespace std;

// 函数声明
float Sn_small2big(int n);    // 从小到大求和
float Sn_big2small(int n);    // 从大到小求和  
double Sn_accuracy(int n);    // 精确值计算

int main()
{
    // 定义数组存储三种方法的结果
    float Sn_s2b[3], Sn_b2s[3];  // 单精度浮点数结果
    double Sn_acc[3];            // 双精度浮点数结果（精确值）
    double e_s2b[3], e_b2s[3];   // 误差数组
    
    // 设置输出格式：固定小数点，15位小数精度
    cout << fixed << setprecision(15);
    
    // 循环测试三个不同的n值：100, 10000, 1000000
    for (int i = 0; i <= 2; i++)
    {
        static int n = 1;  // 静态变量，保持值在循环间不变
        n = n * 100;       // n依次为：1*100=100, 100*100=10000, 10000*100=1000000
        
        // 计算三种方法的结果
        Sn_acc[i] = Sn_accuracy(n);    // 精确值（使用双精度和数学公式）
        Sn_s2b[i] = Sn_small2big(n);   // 从小到大求和（单精度）
        Sn_b2s[i] = Sn_big2small(n);   // 从大到小求和（单精度）
        
        // 计算误差：精确值 - 近似值
        e_s2b[i] = Sn_acc[i] - (double)Sn_s2b[i];  // 从小到大求和的误差
        e_b2s[i] = Sn_acc[i] - (double)Sn_b2s[i];  // 从大到小求和的误差
        
        // 输出结果
        cout << "n=" << n << "  Sn_acc=" << Sn_acc[i] << endl;
        cout << "Sn_small2big: " << Sn_s2b[i] << ", e: " << e_s2b[i] << endl;
        cout << "Sn_big2small: " << Sn_b2s[i] << ", e: " << e_b2s[i] << endl;
        cout << endl;
    }
}

/**
 * 从小到大求和
 * 从i=2开始到i=n，依次累加 1/(i²-1)
 * 这种方法在数值计算中容易产生较大的舍入误差
 * 因为先加的小数可能会被后面的大数"淹没"
 * 
 * @param n 求和的上限
 * @return 级数和（单精度浮点数）
 */
float Sn_small2big(int n)
{
    float Sn = 0;  // 初始化累加器
    
    // 从2到n依次累加
    for (int i = 2; i <= n; i++)
    {
        // 累加项：1/(i²-1)
        // 注意：使用1.0而不是1，确保进行浮点数除法
        Sn += 1.0 / (i * i - 1);
    }
    return Sn;
}

/**
 * 从大到小求和
 * 从i=n开始到i=2，依次累加 1/(i²-1)
 * 这种方法在数值计算中通常更精确
 * 因为先加的大数不会被后面的小数影响精度
 * 
 * @param n 求和的上限  
 * @return 级数和（单精度浮点数）
 */
float Sn_big2small(int n)
{
    float Sn = 0;  // 初始化累加器
    
    // 从n到2依次累加（递减）
    for (int i = n; i >= 2; i--)
    {
        // 累加项：1/(i²-1)
        Sn += 1.0 / (i * i - 1);
    }
    return Sn;
}

/**
 * 精确值计算
 * 使用数学公式直接计算级数的精确值
 * 公式推导：1/(i²-1) = 1/2 * (1/(i-1) - 1/(i+1))
 * 级数展开后大部分项会相互抵消
 * 最终得到：S_n = 1/2 * (3/2 - 1/n - 1/(n+1))
 * 
 * @param n 求和的上限
 * @return 级数的精确值（双精度浮点数）
 */
double Sn_accuracy(int n)
{
    double Sn;
    // 使用精确公式计算
    // 1/2 * (3/2 - 1/n - 1/(n+1))
    Sn = 0.5 * (1.5 - 1.0 / n - 1.0 / (n + 1));
    return Sn;
}

/**
 * 程序说明：
 * 
 * 数学背景：
 * 级数 S_n = Σ_{i=2}^n 1/(i²-1) 可以通过部分分式分解：
 * 1/(i²-1) = 1/2 * [1/(i-1) - 1/(i+1)]
 * 展开后形成望远镜级数，大部分项相互抵消
 * 
 * 数值分析：
 * 1. 从小到大求和：先加小数后加大数，小数可能被大数"淹没"，精度较低
 * 2. 从大到小求和：先加大数后加小数，精度较高
 * 3. 精确值：使用数学公式，精度最高
 * 
 * 误差分析：
 * 通过比较三种方法的差异，可以观察到：
 * - 从大到小求和的误差通常小于从小到大求和的误差
 * - 随着n增大，误差可能会累积
 * - 单精度浮点数的精度限制约为7位有效数字
 * 
 * 运行结果预期：
 * 程序会输出n=100, 10000, 1000000时的结果对比
 * 可以明显看到从大到小求和的精度优势
 */