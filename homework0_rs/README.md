# 整数溢出和浮点数精度问题研究

## 项目概述

本项目将C++代码迁移到Rust，用于研究整数溢出和浮点数精度问题在不同编程语言中的表现。通过计算级数求和，对比不同计算方法的精度差异。

## 主要功能

### 1. 级数求和计算
计算级数：Sn = Σ(1/(i²-1)) 从 i=2 到 n

提供四种计算方法：
- **从小到大累加** (`sn_small_to_big`)
- **从大到小累加** (`sn_big_to_small`) 
- **精确数学公式** (`sn_accuracy`)
- **调试和分析版本** (`sn_small_to_big_debug`, `sn_small_to_big_detailed`)

### 2. 整数溢出测试
对比不同语言中整数溢出的行为差异。

### 3. 浮点数精度分析
分析浮点数累加过程中的精度损失问题。

## 整数溢出行为对比

### C++中的整数溢出
- **有符号整数溢出**：未定义行为(UB)，实际实现通常是wrap around
- **无符号整数溢出**：明确定义为wrap around
- **特点**：编译器和平台相关，缺乏安全性保证

### Rust中的整数溢出
- **Debug模式**：溢出会导致panic（程序崩溃）
- **Release模式**：溢出会wrap around（与C++类似）
- **安全操作**：
  - `wrapping_add()`: 显式wrap around
  - `checked_add()`: 返回Option，安全处理溢出
  - `saturating_add()`: 达到边界时饱和
- **特点**：类型安全，编译时检查

### 示例对比

```rust
let max_i32 = i32::MAX;

// Rust安全操作
let wrapped = max_i32.wrapping_add(1);  // -2147483648
let checked = max_i32.checked_add(1);   // None
let saturated = max_i32.saturating_add(1); // 2147483647

// C++中（未定义行为）
// int max_int = INT_MAX;
// max_int + 1; // 未定义行为
```

## 浮点数精度问题

### 累加顺序的影响
- **从小到大累加**：大数吃小数，精度损失严重
- **从大到小累加**：相对精度更高
- **双精度浮点数**：提供更高的精度

### 实验结果
- 当n=1000000时：
  - 从小到大：14.357358
  - 从大到小：14.392652  
  - 双精度：14.392726722864989
  - 精度差异：0.03529358

### 浮点数表示问题
- **单精度浮点数**：23位尾数，约6-7位十进制精度
- **双精度浮点数**：52位尾数，约15-16位十进制精度
- **ULP（最小精度单位）**：浮点数能表示的最小差值

## 关键发现

1. **整数溢出安全性**：Rust通过类型系统提供更好的安全性保障
2. **浮点数精度**：累加顺序显著影响最终结果的精度
3. **数值稳定性**：从大到小的累加顺序通常更稳定
4. **调试工具**：Rust提供了丰富的数值分析工具

## 运行说明

### 标准运行
```bash
cd homework0_rs
cargo run
```

### 构建优化版本
```bash
# 标准Release版本
cargo build --release

# 最小体积版本
cargo build --profile min-size

# 比较所有版本大小
./build_sizes.sh
```

## 项目结构

```
homework0_rs/
├── src/
│   └── main.rs          # 主程序文件
├── Cargo.toml           # 项目配置（包含优化设置）
├── build_sizes.sh       # 文件大小比较脚本
├── build_sizes.bat      # Windows文件大小比较脚本
└── README.md            # 项目说明
```

## 优化结果

### 可执行文件大小对比
- **Debug版本**: 175 KB
- **Release版本**: 140 KB (节省35KB，约20%)
- **最小体积版本**: 140 KB (节省35KB，约20%)

### 优化配置
- `opt-level = "z"`: 最小体积优化
- `lto = true`: 链接时优化
- `codegen-units = 1`: 减少代码生成单元
- `panic = "abort"`: 使用abort而不是unwinding
- `strip = true`: 移除调试符号

## 结论

通过对比C++和Rust在整数溢出和浮点数精度方面的表现，可以看出：

1. **安全性**：Rust的整数溢出处理更加安全可控
2. **精度**：浮点数运算的精度问题在所有语言中都存在
3. **工具链**：Rust提供了更好的数值分析工具和类型安全保证
4. **优化**：Rust提供了灵活的编译优化选项，可显著减小可执行文件体积

这个项目展示了数值计算中常见的问题，以及如何在不同编程语言中处理这些问题。